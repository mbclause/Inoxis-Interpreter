/*
File: Interpreter.cpp
Description: member function defns for Interpreter class
*/


// include statements
#include "Interpreter.h"



/*
Function: run
Description: main driver for the interpreter, calls the main function for each phase of the Interpreter.
*/
void     Interpreter::run(antlr4::ANTLRInputStream input)
{
	// pass the input to hte lexer
	myLexer lexer(input);

	// the lexer feeds tokens to the antlr common token stream object
	antlr4::CommonTokenStream tokens(&lexer);

	// pass that to the parser, which will create the parse tree
	InoxisParser parser(&tokens);

	antlr4::tree::ParseTree* tree = parser.program();

	// check if there are any errors in the lexing and parsing phases
	int numLexErrors = lexer.getErrorCount();

	size_t numParseErrors = parser.getNumberOfSyntaxErrors();

	// if there are no errors...
	if (numLexErrors + numParseErrors == 0)
	{
		// create an antlr parse tree walker object
		antlr4::tree::ParseTreeWalker walker;

		// use the symbol table class to walk the parse tree
		walker.walk(&symTable, tree);

		// if no symbol errors...
		if (symTable.numErrors == 0)
		{
			// walk the tree again with the MemSafetyPass class
			MemSafetyPass  memPass(symTable.treeFuncSymbols);

			walker.walk(&memPass, tree);

			// if no memory safety errors...
			if (memPass._numErrors == 0)
			{

				// output of this walk will be a GArray of function structs
				// this will be passed to the VM
				VMInputPass  vmInput(memPass.statLists, symTable.treeFuncSymbols, symTable.varListProp);

				walker.walk(&vmInput, tree);

				// compile and execute the program using the virtual machine
				VMMain(vmInput.functions);
			}
		}
	}
} // end run




/*
Function: report_error
*/
void Interpreter::report_error(ERROR_TYPE type, int line)
{
	string error_type;

	if (type == SYNTAX_ERROR)
		error_type = "SYNTAX ERROR";
	else
		error_type = "MEMORY SAFETY ERROR";

	cerr << error_type << " at line " << line << ".\n";

	error_count++;
} // end report_error



/*
Function: printVMInput
Description: print all of the input data generated by the VMInput Pass
Parameters: input - a garray of function structs
*/
void Interpreter::printVMInput(GArray* input)
{
	// for each function in the input...
	for (unsigned i = 0; i < input->len; i++)
	{
		// get the function
		function func = g_array_index(input, function, i);

		cout << "Function " << i + 1 << endl;

		// print the size of the locals array
		cout << "size of locals: " << func.symbols->len << endl;

		// loop through all statements
		for (unsigned j = 0; j < func.statements->len; j++)
		{
			statement stat = g_array_index(func.statements, statement, j);

			printStatement(stat);

			cout << endl;
		}

		cout << endl;
	}
} // end printVMInput